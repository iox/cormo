<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CORMO - adapters.postgresql.coffee</title><link href="../bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css"><link href="../google-code-prettify/prettify.css" rel="stylesheet" type="text/css"><link href="../style.css" rel="stylesheet" type="text/css"></head><body data-spy="scroll" data-target=".sidebar"><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><div class="container-fluid"><ul class="nav"><li class=""><a href="../index.html">Home</a></li><li class="dropdown "><a data-toggle="dropdown" href="#" class="dropdown-toggle">Guides <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../guides/Association.html">Association</a></li><li><a href="../guides/CLI.html">CLI</a></li><li><a href="../guides/Callback.html">Callback</a></li><li><a href="../guides/Constraint.html">Constraint</a></li><li><a href="../guides/CreateRecords.html">CreateRecords</a></li><li><a href="../guides/DefineModels.html">DefineModels</a></li><li><a href="../guides/Geospatial.html">Geospatial</a></li><li><a href="../guides/Miscellaneous.html">Miscellaneous</a></li><li><a href="../guides/Query.html">Query</a></li><li><a href="../guides/Validation.html">Validation</a></li></ul></li><li class=""><a href="../modules/cormo.html">Modules</a></li><li class=""><a href="../classes/ColumnProperty.html">Classes</a></li><li class="dropdown active"><a data-toggle="dropdown" href="#" class="dropdown-toggle">Files - adapters.postgresql.coffee <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../files/command.coffee.html">command.coffee</a></li><li><a href="../files/connection.coffee.html">connection.coffee</a></li><li><a href="../files/index.coffee.html">index.coffee</a></li><li><a href="../files/inflector.coffee.html">inflector.coffee</a></li><li><a href="../files/model.coffee.html">model.coffee</a></li><li><a href="../files/query.coffee.html">query.coffee</a></li><li><a href="../files/types.coffee.html">types.coffee</a></li><li><a href="../files/util.coffee.html">util.coffee</a></li><li><a href="../files/adapters.base.coffee.html">adapters.base.coffee</a></li><li><a href="../files/adapters.mongodb.coffee.html">adapters.mongodb.coffee</a></li><li><a href="../files/adapters.mysql.coffee.html">adapters.mysql.coffee</a></li><li><a href="../files/adapters.postgresql.coffee.html">adapters.postgresql.coffee</a></li><li><a href="../files/adapters.redis.coffee.html">adapters.redis.coffee</a></li><li><a href="../files/adapters.sql_base.coffee.html">adapters.sql_base.coffee</a></li><li><a href="../files/adapters.sqlite3.coffee.html">adapters.sqlite3.coffee</a></li><li><a href="../files/adapters.sqlite3_memory.coffee.html">adapters.sqlite3_memory.coffee</a></li><li><a href="../files/command.console.coffee.html">command.console.coffee</a></li><li><a href="../files/connection.association.coffee.html">connection.association.coffee</a></li><li><a href="../files/connection.manipulate.coffee.html">connection.manipulate.coffee</a></li><li><a href="../files/model.cache.coffee.html">model.cache.coffee</a></li><li><a href="../files/model.callback.coffee.html">model.callback.coffee</a></li><li><a href="../files/model.persistence.coffee.html">model.persistence.coffee</a></li><li><a href="../files/model.query.coffee.html">model.query.coffee</a></li><li><a href="../files/model.timestamp.coffee.html">model.timestamp.coffee</a></li><li><a href="../files/model.validate.coffee.html">model.validate.coffee</a></li></ul></li></ul><div class="options"><label class="checkbox"><input id="options-private" type="checkbox"> Private </label></div></div></div></div><div class="container-fluid content"><div class="row-fluid"><div class="span3 visible-desktop"><div data-spy="affix" class="span3 sidebar"><ul class="nav nav-list cormo-sidenav"><li><a href="../files/command.coffee.html">command.coffee</a></li><li><a href="../files/connection.coffee.html">connection.coffee</a></li><li><a href="../files/index.coffee.html">index.coffee</a></li><li><a href="../files/inflector.coffee.html">inflector.coffee</a></li><li><a href="../files/model.coffee.html">model.coffee</a></li><li><a href="../files/query.coffee.html">query.coffee</a></li><li><a href="../files/types.coffee.html">types.coffee</a></li><li><a href="../files/util.coffee.html">util.coffee</a></li><li class="nav-header">adapters</li><li><a href="../files/adapters.base.coffee.html">base.coffee</a></li><li><a href="../files/adapters.mongodb.coffee.html">mongodb.coffee</a></li><li><a href="../files/adapters.mysql.coffee.html">mysql.coffee</a></li><li class="active"><a href="../files/adapters.postgresql.coffee.html">postgresql.coffee</a></li><li><a href="../files/adapters.redis.coffee.html">redis.coffee</a></li><li><a href="../files/adapters.sql_base.coffee.html">sql_base.coffee</a></li><li><a href="../files/adapters.sqlite3.coffee.html">sqlite3.coffee</a></li><li><a href="../files/adapters.sqlite3_memory.coffee.html">sqlite3_memory.coffee</a></li><li class="nav-header">command</li><li><a href="../files/command.console.coffee.html">console.coffee</a></li><li class="nav-header">connection</li><li><a href="../files/connection.association.coffee.html">association.coffee</a></li><li><a href="../files/connection.manipulate.coffee.html">manipulate.coffee</a></li><li class="nav-header">model</li><li><a href="../files/model.cache.coffee.html">cache.coffee</a></li><li><a href="../files/model.callback.coffee.html">callback.coffee</a></li><li><a href="../files/model.persistence.coffee.html">persistence.coffee</a></li><li><a href="../files/model.query.coffee.html">query.coffee</a></li><li><a href="../files/model.timestamp.coffee.html">timestamp.coffee</a></li><li><a href="../files/model.validate.coffee.html">validate.coffee</a></li></ul></div></div><div class="span9"><section><h1>adapters.postgresql.coffee</h1></section><pre class="prettyprint">try
  pg = require 'pg'
catch e
  console.log 'Install pg module to use this adapter'
  process.exit 1

SQLAdapterBase = require './sql_base'
types = require '../types'
tableize = require('../inflector').tableize
async = require 'async'
_ = require 'underscore'

_typeToSQL = (property) -&gt;
  if property.array
    return 'VARCHAR(255)'
  switch property.type
    when types.String then 'VARCHAR(255)'
    when types.Number then 'DOUBLE PRECISION'
    when types.Boolean then 'BOOLEAN'
    when types.Integer then 'INT'
    when types.Date then 'TIMESTAMP WITHOUT TIME ZONE'
    when types.Object then 'VARCHAR(255)'

_propertyToSQL = (property) -&gt;
  type = _typeToSQL property
  if type
    if property.required
      type += ' NOT NULL'
    else
      type += ' NULL'
    if property.unique
      type += ' UNIQUE'
    return type

##
# Adapter for PostgreSQL
# @namespace adapter
class PostgreSQLAdapter extends SQLAdapterBase
  key_type: types.Integer
  native_integrity: true
  _param_place_holder: (pos) -&gt; '$' + pos
  _contains_op: 'ILIKE'

  ##
  # Creates a PostgreSQL adapter
  constructor: (connection) -&gt;
    @_connection = connection

  _query: (sql, data, callback) -&gt;
    #console.log 'PostgreSQLAdapter:', sql
    @_client.query sql, data, (error, result) -&gt;
      callback error, result

  _createTable: (model, callback) -&gt;
    table = tableize model
    model_class = @_connection.models[model]
    sql = []
    sql.push 'id SERIAL PRIMARY KEY'
    for column, property of model_class._schema
      column_sql = _propertyToSQL property
      if column_sql
        sql.push property._dbname + ' ' + column_sql
    for integrity in model_class._integrities
      if integrity.type is 'child_nullify'
        sql.push &quot;FOREIGN KEY (#{integrity.column}) REFERENCES #{tableize integrity.parent._name}(id) ON DELETE SET NULL&quot;
      else if integrity.type is 'child_restrict'
        sql.push &quot;FOREIGN KEY (#{integrity.column}) REFERENCES #{tableize integrity.parent._name}(id) ON DELETE RESTRICT&quot;
      else if integrity.type is 'child_delete'
        sql.push &quot;FOREIGN KEY (#{integrity.column}) REFERENCES #{tableize integrity.parent._name}(id) ON DELETE CASCADE&quot;
    sql = &quot;CREATE TABLE #{table} ( #{sql.join ','} )&quot;
    @_query sql, (error) =&gt;
      return callback PostgreSQLAdapter.wrapError 'unknown error', error if error
      async.forEach model_class._indexes, (index, callback) =&gt;
        columns = []
        for column, order of index.columns
          order = if order is -1 then 'DESC' else 'ASC'
          columns.push column + ' ' + order
        unique = if index.options.unique then 'UNIQUE ' else ''
        sql = &quot;CREATE #{unique}INDEX #{index.options.name} ON #{table} (#{columns.join ','})&quot;
        @_query sql, callback
      , (error) -&gt;
        return callback PostgreSQLAdapter.wrapError 'unknown error', error if error
        callback null

  _alterTable: (model, columns, callback) -&gt;
    # TODO
    callback null

  ## @override AdapterBase::applySchema
  applySchema: (model, callback) -&gt;
    table = tableize model
    @_query &quot;SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name=$1&quot;, [table], (error, result) =&gt;
      columns = result?.rows
      if error or columns.length is 0
        @_createTable model, callback
      else
        @_alterTable model, columns, callback

  ## @override AdapterBase::drop
  drop: (model, callback) -&gt;
    table = tableize model
    @_query &quot;DROP TABLE IF EXISTS #{table}&quot;, (error) -&gt;
      return callback PostgreSQLAdapter.wrapError 'unknown error', error if error
      callback null

  _getModelID: (data) -&gt;
    Number data.id

  _processSaveError = (model, error, callback) -&gt;
    if error.code is '42P01'
      error = new Error('table does not exist')
    else if error.code is '23505'
      column = ''
      key = error.message.match /unique constraint \&quot;(.*)\&quot;/
      if key?
        column = key[1]
        key = column.match new RegExp &quot;#{tableize model}_([^']*)_key&quot;
        if key?
          column = key[1]
        column = ' ' + column
      error = new Error('duplicated' + column)
    else
      error = PostgreSQLAdapter.wrapError 'unknown error', error
    callback error

  _buildUpdateSetOfColumn: (property, data, values, fields, places, insert) -&gt;
    dbname = property._dbname
    values.push data[dbname]
    if insert
      fields.push dbname
      places.push '$' + values.length
    else
      fields.push dbname + '=$' + values.length

  _buildUpdateSet: (model, data, values, insert) -&gt;
    schema = @_connection.models[model]._schema
    fields = []
    places = []
    for column, property of schema
      @_buildUpdateSetOfColumn property, data, values, fields, places, insert
    [ fields.join(','), places.join(',') ]

  _buildPartialUpdateSet: (model, data, values) -&gt;
    schema = @_connection.models[model]._schema
    fields = []
    places = []
    for column, value of data
      property = _.find schema, (item) -&gt; return item._dbname is column
      @_buildUpdateSetOfColumn property, data, values, fields, places
    [ fields.join(','), places.join(',') ]

  ## @override AdapterBase::create
  create: (model, data, callback) -&gt;
    values = []
    [ fields, places ] = @_buildUpdateSet model, data, values, true
    sql = &quot;INSERT INTO #{tableize model} (#{fields}) VALUES (#{places}) RETURNING id&quot;
    @_query sql, values, (error, result) -&gt;
      rows = result?.rows
      return _processSaveError model, error, callback if error
      if rows?.length is 1 and rows[0].id?
        callback null, rows[0].id
      else
        callback new Error 'unexpected rows'

  ## @override AdapterBase::createBulk
  createBulk: (model, data, callback) -&gt;
    values = []
    fields = undefined
    places = []
    data.forEach (item) =&gt;
      [ fields, places_sub ] = @_buildUpdateSet model, item, values, true
      places.push '(' + places_sub + ')'
    sql = &quot;INSERT INTO #{tableize model} (#{fields}) VALUES #{places.join ','} RETURNING id&quot;
    @_query sql, values, (error, result) -&gt;
      return _processSaveError model, error, callback if error
      ids = result?.rows.map (row) -&gt; row.id
      if ids.length is data.length
        callback null, ids
      else
        callback new Error 'unexpected rows'

  ## @override AdapterBase::update
  update: (model, data, callback) -&gt;
    values = []
    [ fields ] = @_buildUpdateSet model, data, values
    values.push data.id
    sql = &quot;UPDATE #{tableize model} SET #{fields} WHERE id=$#{values.length}&quot;
    @_query sql, values, (error) -&gt;
      return _processSaveError model, error, callback if error
      callback null

  ## @override AdapterBase::updatePartial
  updatePartial: (model, data, conditions, options, callback) -&gt;
    values = []
    [ fields ] = @_buildPartialUpdateSet model, data, values
    sql = &quot;UPDATE #{tableize model} SET #{fields}&quot;
    if conditions.length &gt; 0
      try
        sql += ' WHERE ' + @_buildWhere @_connection.models[model]._schema, conditions, values
      catch e
        return callback e
    @_query sql, values, (error, result) -&gt;
      return _processSaveError model, error, callback if error
      callback null, result.rowCount

  ## @override AdapterBase::findById
  findById: (model, id, options, callback) -&gt;
    select = @_buildSelect @_connection.models[model], options.select
    table = tableize model
    @_query &quot;SELECT #{select} FROM #{table} WHERE id=$1 LIMIT 1&quot;, [id], (error, result) =&gt;
      rows = result?.rows
      return callback PostgreSQLAdapter.wrapError 'unknown error', error if error
      if rows?.length is 1
        if options.return_raw_instance
          callback null, @_refineRawInstance model, rows[0], options.select
        else
          callback null, @_convertToModelInstance model, rows[0], options.select
      else if rows?.length &gt; 1
        callback new Error 'unknown error'
      else
        callback new Error 'not found'

  ## @override AdapterBase::find
  find: (model, conditions, options, callback) -&gt;
    if options.group_by or options.group_fields
      select = @_buildGroupFields options.group_by, options.group_fields
    else
      select = @_buildSelect @_connection.models[model], options.select
    params = []
    sql = &quot;SELECT #{select} FROM #{tableize model}&quot;
    if conditions.length &gt; 0
      try
        sql += ' WHERE ' + @_buildWhere @_connection.models[model]._schema, conditions, params
      catch e
        return callback e
    if options.group_by
      sql += ' GROUP BY ' + options.group_by.join ','
    if options.conditions_of_group.length &gt; 0
      try
        sql += ' HAVING ' + @_buildWhere options.group_fields, options.conditions_of_group, params
      catch e
        return callback e
    if options?.orders.length &gt; 0
      orders = options.orders.map (order) -&gt;
        if order[0] is '-'
          return order[1..] + ' DESC'
        else
          return order + ' ASC'
      sql += ' ORDER BY ' + orders.join ','
    if options?.limit?
      sql += ' LIMIT ' + options.limit
      sql += ' OFFSET ' + options.skip if options?.skip?
    else if options?.skip?
      sql += ' LIMIT ALL OFFSET ' + options.skip
    #console.log sql, params
    @_query sql, params, (error, result) =&gt;
      rows = result?.rows
      return callback PostgreSQLAdapter.wrapError 'unknown error', error if error
      if options.group_fields
        callback null, rows.map (record) =&gt; @_convertToGroupInstance model, record, options.group_by, options.group_fields
      else
        if options.return_raw_instance
          callback null, rows.map (record) =&gt; @_refineRawInstance model, record, options.select
        else
          callback null, rows.map (record) =&gt; @_convertToModelInstance model, record, options.select

  ## @override AdapterBase::count
  count: (model, conditions, callback) -&gt;
    params = []
    sql = &quot;SELECT COUNT(*) AS count FROM #{tableize model}&quot;
    if conditions.length &gt; 0
      try
        sql += ' WHERE ' + @_buildWhere @_connection.models[model]._schema, conditions, params
      catch e
        return callback e
    #console.log sql, params
    @_query sql, params, (error, result) =&gt;
      rows = result?.rows
      return callback PostgreSQLAdapter.wrapError 'unknown error', error if error
      return callback error 'unknown error' if rows?.length isnt 1
      callback null, Number(rows[0].count)

  ## @override AdapterBase::delete
  delete: (model, conditions, callback) -&gt;
    params = []
    sql = &quot;DELETE FROM #{tableize model}&quot;
    if conditions.length &gt; 0
      try
        sql += ' WHERE ' + @_buildWhere @_connection.models[model]._schema, conditions, params
      catch e
        return callback e
    #console.log sql, params
    @_query sql, params, (error, result) -&gt;
      return callback new Error 'rejected' if error and error.code is '23503'
      return callback PostgreSQLAdapter.wrapError 'unknown error', error if error or not result?
      callback null, result.rowCount

  ##
  # Connects to the database
  # @param {Object} settings
  # @param {String} [settings.host]
  # @param {Number} [settings.port]
  # @param {String} [settings.user]
  # @param {String} [settings.password]
  # @param {String} settings.database
  # @param {Function} callback
  # @param {Error} callback.error
  connect: (settings, callback) -&gt;
    # connect
    pg.connect
        host: settings.host
        port: settings.port
        user: settings.user
        password: settings.password
        database: settings.database
      , (error, client) =&gt;
        if error?.code is '3D000'
          return callback new Error 'database does not exist'
        return callback PostgreSQLAdapter.wrapError 'failed to connect', error if error

        @_client = client
        return callback null

module.exports = (connection) -&gt;
  new PostgreSQLAdapter connection</pre></div></div></div><script src="http://code.jquery.com/jquery-1.8.2.min.js"></script><script src="../bootstrap/js/bootstrap.min.js"></script><script src="../google-code-prettify/prettify.js"></script><script>$(function() {
  // make result of marked for pretty print
  $('pre code[class^="lang-"]').addClass('.prettyprint');
  window.prettyPrint && prettyPrint()
});
$('body').on('click', '.showcode', function () {
  $(this).parent().find('pre.sourcecode').toggle();
  $('body').scrollspy('refresh');
});
$('#options-private').on('click', function () {
  $('.private').toggle();
  $('body').scrollspy('refresh');
});</script><a href="https://github.com/croquiscom/cormo"><img src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub" class="github-ribbon"></a></body></html>