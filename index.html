<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CORMO - README</title><link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css"><link href="style.css" rel="stylesheet" type="text/css"><link href="google-code-prettify/prettify.css" rel="stylesheet" type="text/css"><link href="tocify/jquery.tocify.css" rel="stylesheet" type="text/css"></head><body data-spy="scroll" data-target=".sidebar"><div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><div class="container-fluid"><ul class="nav"><li class="active"><a href="index.html">Home</a></li><li class=""><a href="AdapterBase.html">Classes</a></li></ul></div></div></div><div class="container-fluid content extra"><div class="row-fluid"><div class="span3"><div id="toc"></div></div><div class="span9"><h1>About</h1>

<p>CORMO is an ORM framework for Node.js.</p>

<p>Currently supports:</p>

<ul>
<li>multi-DB: MySQL, MongoDB, SQLite3, PostgreSQL</li>
<li>constraints</li>
<li>validations</li>
<li>associations</li>
<li>geospatial query</li>
</ul>

<p>Will support:</p>

<ul>
<li>auto table migration</li>
<li>more DB, validations, associations, ...</li>
</ul>

<p>This project is not yet stabilized.<br />API can be changed.</p>

<h1>Usage</h1>

<h2>Connect to DB</h2>

<div class="highlight"><pre lang="coffeescript">DBConnection = require('cormo').DBConnection

connection = new DBConnection 'mysql', database: 'test'

another = new DBConnection 'mongodb', database: 'test'
</pre></div>

<p>See documents for each adapter(<a href='AdapterBase.html#AdapterBase'>AdapterBase</a>) for detail options.</p>

<h2>Define models</h2>

<div class="highlight"><pre lang="coffeescript"> # this will create two tables - users, posts.

User = connection.model 'User',
  name: String
  age: Number

 # 'String' is the same as '{ type: String }'
Post = connection.model 'Post',
  title: String
  body: { type: String }

connection.applySchemas (error) ->
  console.log error
</pre></div>

<p>See <a href='DBConnection.html#DBConnection__model'>DBConnection::model</a>, <a href='DBConnection.html#DBConnection__applySchemas'>DBConnection::applySchemas</a> for more details.</p>

<h2>Create a record</h2>

<div class="highlight"><pre lang="coffeescript"> # new with no data
user1 = new User()
user1.name = 'John Doe'
user1.age = 27
user1.save (error) ->
  console.log error

 # new with data
user2 = new User name: 'John Doe', age: 27
user2.save (error) ->
  console.log error

 # build is the same as new
user3 = User.build name: 'John Doe', age: 27
user3.save (error) ->
  console.log error

 # create is the same as build and save
User.create { name: 'John Doe', age: 27 }, (error, user4) ->
  console.log error
</pre></div>

<p>See <a href='DBModel.html#DBModel__constructor'>DBModel::constructor</a>, <a href='DBModel.html#DBModel__save'>DBModel::save</a>, <a href='DBModel.html#DBModel_build'>DBModel.build</a>, <a href='DBModel.html#DBModel_create'>DBModel.create</a> for more details.</p>

<h2>Query</h2>

<div class="highlight"><pre lang="coffeescript"> # simple query
 # the same as "SELECT * FROM users WHERE age=27"
User.where age: 27, (error, users) ->
  console.log users

 # else you can use query chain
User.where(age: 27).exec (error, users) ->
  console.log users

 # select partial columns
 # the same as "SELECT name,age FROM users"
User.select 'name age', (error, users) ->
  console.log users

 # two condition
 # the same as "SELECT * FROM users WHERE name='John Doe' AND age=27"
User.where name: 'John Doe', age: 27, (error, users) ->
  console.log users

 # using query chain
User.where(name: 'John Doe').where(age: 27).exec (error, users) ->
  console.log users

 # find by id, return a single record
User.find 1, (error, user) ->
  console.log user

 # get count of all records
 # the same as "SELECT COUNT(*) FROM users"
User.count (error, count) ->
  console.log count

 # get count of matched records
 # the same as "SELECT COUNT(*) FROM users WHERE age=27"
User.count age: 27, (error, count) ->
  console.log count

 # delete records that match conditions
 # the same as "DELETE FROM users WHERE age=27"
User.delete age: 27, (error, count) ->
  console.log count

 # or condition, similar syntax with MongoDB
 # the same as "SELECT * FROM users WHERE name='John Doe' OR age=27"
User.where $or: [ { name: 'John Doe' }, { age: 27 } ], (error, users) ->
  console.log users

 # comparison
 # the same as "SELECT * FROM users WHERE age > 30 AND age <= 45"
User.where [ { age: { $gt: 30 } }, { age: { $lte: 45 } } ], (error, users) ->
  console.log users

 # containing some text in case insensitive
 # the same as "SELECT * FROM users WHERE name LIKE '%smi%'"
User.where { name: { $contains: 'smi' } }, (error, users) ->
  console.log users

 # limit records
 # the same as "SELECT * FROM users WHERE age<40 LIMIT 3"
User.where(age: { $lt: 40 }).limit(3).exec (error, users) ->
  console.log users
</pre></div>

<p>See <a href='DBModel.html#DBModel_find'>DBModel.find</a>, <a href='DBModel.html#DBModel_where'>DBModel.where</a>, <a href='DBModel.html#DBModel_count'>DBModel.count</a>, <a href='DBModel.html#DBModel_delete'>DBModel.delete</a>, <a href='DBQuery.html#DBQuery'>DBQuery</a> for more details.</p>

<h2>Constraints</h2>

<p>Currently supports 'unique' and 'required'(not null).</p>

<p>'unique' is supported on the database layer.<br />'required' is supported on the CORMO layer(while validating).</p>

<p>The column unique but not required can have multiple null values.</p>

<div class="highlight"><pre lang="coffeescript">User = connection.model 'User',
  name: { type: String, required: true }
  age: { type: Number, required: true }
  email: { type: String, unique: true, required: true }

connection.applySchemas()

User.create { name: 'Bill Smith', age: 45, email: '<a href='mailto:bill@foo.org'>bill@foo.org</a>' }, (error, user1) ->
  User.create { name: 'Bill Simpson', age: 38, email: '<a href='mailto:bill@foo.org'>bill@foo.org</a>' }, (error, user2) ->
    # error.message will be 'duplicated email' or 'duplicated'
</pre></div>

<p>See <a href='DBConnection.html#DBConnection__model'>DBConnection::model</a> for more details.</p>

<h2>Validations</h2>

<p>If you want validations, adds a validator using <a href='DBModel.html#DBModel_addValidator'>DBModel.addValidator</a>.</p>

<p>If a record is invalid, throws an error, or returns false or an error string in the validator.</p>

<div class="highlight"><pre lang="coffeescript">User = models.User = connection.model 'User',
  name: String
  age: Number
  email: String

 # checkes age validity
User.addValidator (record) ->
  if record.age < 18
    return 'too young'

 # checkes email validity
User.addValidator (record) ->
  if record.email and not /^\w+@.+$/.test record.email
    throw new Error 'invalid email'
  return true

connection.applySchemas()

User.create { name: 'John Doe', age: 10, email: 'invalid' }, (error, user) ->
  # error.message will be 'invalid email,too young' or 'too young,invalid email'
</pre></div>

<p>See <a href='DBModel.html#DBModel_addValidator'>DBModel.addValidator</a> for more details.</p>

<h2>Associations</h2>

<div class="highlight"><pre lang="coffeescript">User = connection.model 'User',
  name: String
  age: Number

Post = connection.model 'Post',
  title: String
  body: String

 # one-to-many association
 # this will add 'user_id' to the Post model
User.hasMany Post
Post.belongsTo User

 # one-to-many association with 'as'
 # this will add 'parent_post_id' to the Post model
Post.hasMany Post, as: 'comments', foreign_key: 'parent_post_id'
Post.belongsTo Post, as: 'parent_post'

 # you must call applySchemas after defining association
connection.applySchemas()

 # get associated objects
user.posts (error, records) ->
  console.log records
post.user (error, record) ->
  console.log record
post.comments (error, records) ->
  console.log records
post.parent_post (error, record) ->
  console.log record

 # returned objects are cached, give true to reload
user.posts true, (error, records) ->
  console.log records

 # two ways to create an associated object
Post.create { title: 'first post', body: 'This is the 1st post.', user_id: user.id }, (error, post) ->
  console.log post

post = user.posts.build title: 'first post', body: 'This is the 1st post.'
post.save (error) ->
  console.log error
</pre></div>

<p>See <a href='DBModel.html#DBModel_hasMany'>DBModel.hasMany</a>, <a href='DBModel.html#DBModel_belongsTo'>DBModel.belongsTo</a> for more details.</p>

<h2>Geospatial query</h2>

<p>Currently, we supports only near query of 2D location in MongoDB and MySQL.</p>

<div class="highlight"><pre lang="coffeescript">Place = connection.model 'Place',
  name: String
  location: DBConnection.GeoPoint

connection.applySchemas()

 # create 
Place.create name: 'Carrier Dome', location: [-76.136131, 43.036240]

 # query
Place.where().near(location: [-5, 45]).limit(4).exec (error, places) ->
  console.log places
</pre></div>

<p>See <a href='DBQuery.html#DBQuery__near'>DBQuery::near</a> for more details.</p></div></div></div><script src="http://code.jquery.com/jquery-1.8.2.min.js"></script><script src="bootstrap/js/bootstrap.min.js"></script><script src="google-code-prettify/prettify.js"></script><script>$(function() {
  // make result of github-flavored-markdown for pretty print
  $('.highlight').find('pre').addClass('.prettyprint');
  window.prettyPrint && prettyPrint()
});
$('body').on('click', '.showcode', function () {
  $(this).parent().find('pre.sourcecode').toggle();
});</script><script src="http://code.jquery.com/ui/1.9.0/jquery-ui.min.js"></script><script src="tocify/jquery.tocify.min.js"></script><script>$(function() {
  $('#toc').tocify();
});</script></body></html>